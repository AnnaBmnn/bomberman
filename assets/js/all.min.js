class Bomb {
    constructor(powerKill, posX, posY, delay, owner, div) {
        this.powerDestruct = 1; // number of cells that can be destructed, always one
        this.powerKill = powerKill; // power range to kill players around
        this.delay = delay;
        this.posX = posX;
        this.posY = posY;
        this.owner = owner;
        this.div = div;
    }
    
    launchBomb() {
        this.div = document.createElement('div');
        this.div.classList.add('bomb');
        this.div.style.top = this.posY + "px"; // + 13 to place the bomb at his feet
        this.div.style.left = this.posX + "px";

        let mapDiv = document.querySelector('.map');        
        mapDiv.appendChild(this.div); 
        let coordCellX = parseInt(this.posX/ 50),
            coordCellY = parseInt(this.posY/50);
        
        for (let i = coordCellX - this.powerKill; i < coordCellX; i++) { // test on Y
            if (i < 0)
                i = 0;
            
            if (0 < i && i < map.columns) {
                //don't test for x
                for (let j = coordCellY - this.powerKill; j < coordCellY; j++) { // test on X
                    if (j < 0)
                        j = 0;
                    
                    if (0 < j && j < map.rows) {
                        
                        let isBlock = false; // initialise isBlock at false at every loop
                        if (i == coordCellX) {
                            if (map.cells[j][i].status == 'empty') {
                                
                                if (j < coordCellY) {
                                    for (let k = 1; j + k < coordCellY; k++) {
                                        if ( (map.cells[j + k][i].status == 'unbreakable') || (map.cells[j + k][i].status == 'breakable') )
                                            isBlock = true;
                                    }
                                    if (!isBlock)
                                        map.cells[j][i].updateStatus('dangerous', true);
                                }
                            }
                        }
                            
                        else if (j == coordCellY) {
                            if (map.cells[j][i].status == 'empty') {
                                if (i < coordCellX) {
                                    for (let k = 1; i + k < coordCellY; k++) {
                                        if ( (map.cells[j][i + k].status == 'unbreakable') || (map.cells[j][i + k].status == 'breakable') )
                                            isBlock = true;
                                    }
                                    if (!isBlock)
                                        map.cells[j][i].updateStatus('dangerous', true);
                                }
                            }
                        }
                    }
                } 
            }
        }
        
        for (let i = coordCellX + this.powerKill; i >= coordCellX; i--) { // test on Y
            if (i > map.columns - 2)
                i =  map.columns - 2;
        
            if (0 < i && i < map.columns) {
                //don't test for x
                for (let j = coordCellY + this.powerKill; j >= coordCellY; j--) { // test on X
                    if (j > map.rows - 2)
                            j = map.rows - 2;
                    
                    if (0 < j && j < map.rows) {
                        
                        let isBlock = false; // initialise isBlock at false at every loop
                        
                        if ( (i == coordCellX) && (j == coordCellY) ) {
                            if (map.cells[j][i].status == 'empty')
                                map.cells[j][i].updateStatus('dangerous', true);
                            
                        } else if (i == coordCellX) {
                            if (map.cells[j][i].status == 'empty') {
                                
                                if (j > coordCellY) {
                                    for (let k = 1; j - k > coordCellY; k++) {
                                        if ( (map.cells[j - k][i].status == 'unbreakable') || (map.cells[j - k][i].status == 'breakable') )
                                            isBlock = true;
                                    }
                                    if (!isBlock)
                                        map.cells[j][i].updateStatus('dangerous', true);
                                }
                            }
                        }
                            
                        else if (j == coordCellY) {
                            if (map.cells[j][i].status == 'empty') {
                                
                                if (i > coordCellX) {
                                    for (let k = 1; i - k > coordCellY; k++) {
                                        if ( (map.cells[j][i - k].status == 'unbreakable') || (map.cells[j][i - k].status == 'breakable') )
                                            isBlock = true;
                                    }
                                    if (!isBlock)
                                        map.cells[j][i].updateStatus('dangerous', true);
                                }
                            }
                        }
                    }
                } 
            }
        }
    }
    
    destructingBomb() {
        let coordCellX = parseInt(this.posY / 50),
            coordCellY = parseInt(this.posX / 50),
            bombCoordCellX = coordCellX,
            bombCoordCellY = coordCellY;
        
        if (coordCellX - 1 < map.columns)
            bombCoordCellX = coordCellX + 1;
        
        if (coordCellX + 1 > map.columns)
            bombCoordCellX = coordCellX - 1;
        
        if (coordCellY - 1 < map.rows)
            bombCoordCellY = coordCellY + 1;
        
        if (coordCellY + 1 > map.rows)
            bombCoordCellY = coordCellY - 1;
        
        // test if the player is around the bomb + if there is some walls to break, according to the powerKill of the bomb
        if ( (map.cells[bombCoordCellX - 1][coordCellY].status !== 'unbreakable') || (map.cells[bombCoordCellX + 1][coordCellY].status !== 'unbreakable') ) { // prevent breakable cells to be destruct if they are behind unbreakable cell
            for (let i = coordCellX - this.powerDestruct; i <= coordCellX + this.powerDestruct; i++) {
                if (0 < i && i < map.rows) {
                    if (map.cells[i][coordCellY].status == 'breakable') {
                        if (map.cells[i][coordCellY].bonusStatus == 'undiscovered') {
                            map.cells[i][coordCellY].updateStatus('bonus', true);
                            map.cells[i][coordCellY].div.classList.add(map.cells[i][coordCellY].bonus);
                            map.cells[i][coordCellY].bonusStatus = 'discovered';
                            
                        } else
                            map.cells[i][coordCellY].updateStatus('empty', true);
                        
                    } else if (map.cells[i][coordCellY].bonusStatus == 'discovered') {
                        map.cells[i][coordCellY].updateStatus('empty', true);
                        map.cells[i][coordCellY].div.classList.remove(map.cells[i][coordCellY].bonus);
                        map.cells[i][coordCellY].bonusStatus = null;
                    }
                }
            }
        }
        if ( (map.cells[coordCellX][bombCoordCellY - 1].status !== 'unbreakable') || (map.cells[coordCellX][bombCoordCellY + 1].status !== 'unbreakable') ) {
            for (let i = coordCellY - this.powerDestruct; i <= coordCellY + this.powerDestruct; i++) { // test on X
                if (0 < i && i < map.columns) {
                    
                    if (map.cells[coordCellX][i].status == 'breakable') {
                        if (map.cells[coordCellX][i].bonusStatus == 'undiscovered') {
                            map.cells[coordCellX][i].updateStatus('bonus', true);
                            map.cells[coordCellX][i].div.classList.add(map.cells[coordCellX][i].bonus);
                            map.cells[coordCellX][i].bonusStatus = 'discovered';
                            
                        } else
                            map.cells[coordCellX][i].updateStatus('empty', true);
                        
                    } else if (map.cells[coordCellX][i].bonusStatus == 'discovered') {
                        map.cells[coordCellX][i].updateStatus('empty', true);
                        map.cells[coordCellX][i].div.classList.remove(map.cells[coordCellX][i].bonus);
                        map.cells[coordCellX][i].bonusStatus = null;
                    }
                }
            }
        }
        this.div.classList.remove('bomb');  
    }
    
    killingBomb() {
        let coordCellX = parseInt(this.posY / 50),
            coordCellY = parseInt(this.posX / 50);

        for (let i = coordCellX - this.powerKill; i <= coordCellX + this.powerKill; i++) { // test on Y

            if (0 < i && i < map.rows) {
                for (let j = coordCellY - this.powerKill; j <= coordCellY + this.powerKill; j++) { // test on X
                    if (0 < j && j < map.columns) {
                        if (i == coordCellX || j == coordCellY){
                            if (map.cells[i][j].status == 'dangerous')
                                map.cells[i][j].updateStatus('empty', true);
                            for (let k = 0; k < map.pirates.length; k++) {
                                if (map.cells[i][j].posY === parseInt(map.pirates[k].playerPosY/50) && map.cells[i][j].posX === parseInt(map.pirates[k].playerPosX/50)) {
                                    map.pirates[k].playerLives -= 1;
                                }
                            }

                        }

                    }
                }
            }
        }
    }
}
class cell { // class cell
  constructor(posX, posY, status, div) {
    this.posX = posX;
    this.posY = posY;
    this.status = status;
    this.bonusStatus = null;
    this.bonus = null;
    this.div = div;
}
  createDiv(map) {
        this.div = document.createElement('div');
        this.div.classList.add('cell');
        this.div.classList.add(this.status);
        if (!this.bonusStatus == null)
            this.div.classList.add(this.bonusStatus);

        map.appendChild(this.div);
    }

    // newStatus --> Status we want to had / removeStatus --> true or false (removing previous status)
    updateStatus(newStatus, removeStatus) {
        if (removeStatus)
            this.div.classList.remove(this.status);

        this.status = newStatus;

        this.div.classList.add(newStatus);
    }
}

/*
CELL.STATUS

cell.status = empty --> cell is empty
cell.status = unbreakable --> cell is an unbreakable wall
cell.status = breakable --> cell is an breakable wall

*/
let spawnCorner = 4;

class map {
  constructor(rows, columns) {
    this.rows = rows;
    this.columns = columns;
    this.div = document.querySelector('.map');
    this.cells = [rows];
    this.pirates = []; // contains all the players, used by the bomb to know if the bomb kills players or not according to their position on the map
    this.breakableWalls = 100;
    this.bonusNumber = 80;
    this.bonusTypes = ['speed', 'power-bomb', 'add-bomb'];
}
  generateMap() {
        for (let i = 0; i < this.rows; i++) {
            this.cells[i] = [this.columns];

            for (let j = 0; j < this.columns; j++) {
                //define the cell with status unbreakable depending on their place
                let status = 'empty';
                if (this.isUnbreakable(i, j))
                    status = 'unbreakable';
                //define the cell with status breakable randomly
                let myCell = new cell(i, j, status);
                myCell.createDiv(this.div);
                this.cells[i][j] = myCell;
            }
        }
    }
  generateBreakableWall() {
        for (let k = 0; k < this.breakableWalls; k++) {
            //random x and y while the cell[x][y] is a corner or a unbreakableWall
            do {
                var x = alea(1, this.rows);
                var y = alea(1, this.columns);
                if (this.bonusNumber > 0) {
                    var bonus = Math.round(Math.random());
                    if (bonus === 1) {
                        this.bonusNumber--;
                        var alea_bonus = alea(0, this.bonusTypes.length);
                    }
                }
            } while ( (this.isUnbreakable(x, y)) || (this.isCorner(x, y)) );

            this.cells[x][y].updateStatus('breakable', true);

            if (bonus === 1) {
                this.cells[x][y].bonusStatus = 'undiscovered';
                this.cells[x][y].bonus = this.bonusTypes[alea_bonus];
            }
        }
    }

    //test the cell[x][y] is unbreakable depending on their place
  isUnbreakable(x, y) {
        if (x == 0 || x == this.rows - 1 || y == 0 || y == this.columns - 1) // all the cells around
            return true;
        else
        if (y % 2 == 0 && x % 2 == 0) // one cell / 2
            return true;
        return false;
    }

    //test if the cells[x][y] is a corner case (corner case + or - number of powercase) or not
  isCorner(x, y) {
        //check if the random number give a cell in the corner
        if (x == 1) {
            if (y >= 1 && y <= spawnCorner)
                return true;
            else
            if (y <= this.columns && y >= this.columns - spawnCorner - 1)
                return true;
        }
        if (x == this.rows - 2) {
            if (y >= 1 && y <= spawnCorner)
                return true;
            else
            if (y <= this.columns && y >= this.columns - spawnCorner - 1)
                return true;
        }
        if (y == 1) {
            if (x >= 1 && x <= spawnCorner)
                return true;
            else
            if (x <= this.rows && x >= this.rows - spawnCorner - 1)
                return true;
        }
        if (y == this.columns - 2) {
            if (x >= 1 && x <= spawnCorner)
                return true;
            else
            if (x <= this.rows && y >= this.rows - spawnCorner - 1)
                return true;
        }
        return false;
    }
}

function alea(min, max) {
    return (Math.floor((max - min) * Math.random()) + min);
}

map = new map(13, 17);
//console.log(map.cells);
map.generateMap();
map.generateBreakableWall();

// Generate our player
class Player {
  constructor(playerLives, playerPosX, playerPosY, div) {
    this.playerLives = playerLives;    
    this.playerPosX = playerPosX;    
    this.playerPosY = playerPosY; 
    this.movement = new Array(); 
    this.direction = 0;
    this.speed = 10; 
    this.bombDelay = 2000;  
    this.bombKill = 2;
    this.enableBomb = 1;  //number of bomb you can launch  
    this.div = div;
  }

  createPlayer() {
    map.pirates[map.pirates.length] = this; // add the player into the players array   
    this.div = document.createElement('div');        
    this.div.classList.add('avatar_down');
    this.div.style.top = this.playerPosY + 'px';
    this.div.style.left = this.playerPosX + 'px';        
    let mapDiv = document.querySelector('.map');        
    mapDiv.appendChild(this.div); 
  }
  getDirection(){
    var that = this;
    window.addEventListener('keydown', function(e){
      that.direction = e.keyCode ;
      that.movePlayer();
    }, false)
  }

  movePlayer() {
    var that = this;
    that.playerPosX;
    that.playerPosY;
      // Position calcul
      that.posX = Math.round(that.playerPosX / 50); //
      that.posY = Math.round(that.playerPosY / 50); //
//      console.log("Pos x " + that.posX);
//      console.log("Pos y " + that.posY);

      if (this.direction == that.movement[0]) {
        //up
        that.posX = Math.floor((that.playerPosX + 15) / 50); //
        that.posY = Math.floor((that.playerPosY + 25) / 50); //
        if ((map.cells[that.posY][that.posX].status === 'empty') || (map.cells[that.posY][that.posX].status === 'bonus') || (map.cells[that.posY][that.posX].status === 'dangerous')) {
            that.playerPosY -= that.speed;
            that.div.classList.remove(that.sprite[1], that.sprite[2], that.sprite[3]);
            that.div.classList.add(that.sprite[0]);

            pirate_player.bonusCheck(that.posX, that.posY);
        }
      } else if (this.direction == that.movement[1]) {
        //right
        that.posX = Math.floor((that.playerPosX + 35) / 50); //
        that.posY = Math.floor((that.playerPosY + 30) / 50); //
        if ((map.cells[that.posY][that.posX].status === 'empty') || (map.cells[that.posY][that.posX].status === 'bonus') || (map.cells[that.posY][that.posX].status === 'dangerous')) {
            that.playerPosX += that.speed;
            that.div.classList.remove(that.sprite[0], that.sprite[2], that.sprite[3]);
            that.div.classList.add(that.sprite[1]);

            pirate_player.bonusCheck(that.posX, that.posY);
        }
      } else if (this.direction == that.movement[2]) {
        //down
        that.posX = Math.floor((that.playerPosX + 15) / 50); //
        that.posY = Math.floor((that.playerPosY + 35) / 50); //
        if ((map.cells[that.posY][that.posX].status === 'empty') || (map.cells[that.posY][that.posX].status === 'bonus') || (map.cells[that.posY][that.posX].status === 'dangerous')) {
            that.playerPosY += that.speed;
            that.div.classList.remove(that.sprite[1], that.sprite[0], that.sprite[3]);
            that.div.classList.add(that.sprite[2]);

            pirate_player.bonusCheck(that.posX, that.posY);
        }
      } else if (this.direction == that.movement[3]) {
        //left
        that.posX = Math.floor((that.playerPosX - 5) / 50); //
        that.posY = Math.floor((that.playerPosY + 30) / 50); //
        if ((map.cells[that.posY][that.posX].status === 'empty') || (map.cells[that.posY][that.posX].status === 'bonus') || (map.cells[that.posY][that.posX].status === 'dangerous')) {
            that.playerPosX -= that.speed;
            that.div.classList.remove(that.sprite[1], that.sprite[2], that.sprite[0]);
            that.div.classList.add(that.sprite[3]);

            pirate_player.bonusCheck(that.posX, that.posY);
        }
      } else if (this.direction == that.movement[4] && that.enableBomb > 0) {
        that.createBomb();
      }
      that.div.style.top = that.playerPosY + "px";
      that.div.style.left = that.playerPosX + "px";
  }
    
  bonusCheck(posX, posY) {
    if (map.cells[posY][posX].status === 'bonus') {
      
      // Apply bonus to the player
      
      // Speed
      if (map.cells[posY][posX].bonus == map.bonusTypes[0])
        this.speed += 5;
      
      // power-bomb
      else if (map.cells[posY][posX].bonus == map.bonusTypes[1])
        this.bombKill += 1;
        
      // add-bomb
      else if (map.cells[posY][posX].bonus == map.bonusTypes[2])
        this.enableBomb += 1;
      
      // Update cell status to empty
      map.cells[posY][posX].updateStatus('empty', true);
      map.cells[posY][posX].div.classList.remove(map.cells[posY][posX].bonus);
      map.cells[posY][posX].bonusStatus = null;
    }
  }

  createBomb() {
    this.enableBomb -= 1;
    let bomb = new Bomb(this.bombKill, this.playerPosX, this.playerPosY, this.bombDelay, this);
    bomb.launchBomb();
    setTimeout(function() { // delay until the player can launch a bomb again
      pirate_player.enableBomb += 1;
      bomb.destructingBomb();
      bomb.killingBomb();
    }, this.bombDelay);
  }
}

pirate_player = new Player(3, 50, 50);
pirate_player.createPlayer();
pirate_player.movement = [38, 39, 40, 37, 32];
pirate_player.sprite = ['avatar_up', 'avatar_right', 'avatar_down', 'avatar_left'];
pirate_player.getDirection();

// Creation of the AI

class Ai extends Player{
  createPlayer() {
    super.createPlayer(); // keyword "super" is used to call the functions attached to a parent object
    this.roads = new Array();
    this.cell = map.cells[parseInt(this.playerPosY/50)][parseInt(this.playerPosX/50)];
    this.nextCell = this.cell;
    this.roads[0] = new Array(map.cells[parseInt(this.playerPosY/50)][parseInt(this.playerPosX/50)]);
    this.antecedent = new Array();
    this.direction = '';
    this.mode ;
  }
  movePlayer() {
    super.movePlayer();
  }
  alea(max){
    return Math.round(Math.random()*max);
  }
  getNewDirection(){
    var cellsPossibilities = new Array();
    for(let i = this.nextCell.posX -1 ; i<= this.nextCell.posX+ 1; i ++){
      if (0 < i && i < map.rows) {
        for(let j = this.nextCell.posY -1 ; j <= this.nextCell.posY + 1 ; j++){
          if (0 < j && j < map.columns) {
            //we don't test for the case where the player is
            if((i == this.nextCell.posX)^(j == this.nextCell.posY)){
              //we don't test for the case where the player was
              if((map.cells[i][j]!== this.cell)){
                if(map.cells[i][j].status == 'empty')
                  cellsPossibilities[cellsPossibilities.length] = map.cells[i][j];
              } 
            }              
          }
        }
      }
    }
    if(this.direction == 'bomb') {
      // we come back to the previous case
      let _cell = this.nextCell;
      this.nextCell = this.cell;
      this.cell = _cell;

      //we set new direction
      if(this.cell.posX+1 == this.nextCell.posX)
        this.direction = 'down';
      if(this.cell.posX-1 == this.nextCell.posX)
        this.direction = 'up';
      if(this.cell.posY-1 == this.nextCell.posY)
        this.direction = 'left';
      if(this.cell.posY+1 == this.nextCell.posY)
        this.direction = 'right';   
    }else {
      //if the player is stuck, launch bomb
      if(cellsPossibilities.length == 0){
        this.direction = 'bomb';
      }
      else {
        this.cell = this.nextCell;
        //find new case randomly among the empty case around (empty case around stuck in the cellsPossibilies)
        this.nextCell = cellsPossibilities[this.alea(cellsPossibilities.length-1)];
        if(this.cell.posX+1 == this.nextCell.posX)
          this.direction = 'down';
        if(this.cell.posX-1 == this.nextCell.posX)
          this.direction = 'up';
        if(this.cell.posY-1 == this.nextCell.posY)
          this.direction = 'left';
        if(this.cell.posY+1 == this.nextCell.posY)
          this.direction = 'right';      
      }      
    }


  }

  getMovePlayer(){
    var that = this ;
    window.setInterval(function(){
      that.movePlayer() ;
      if((parseInt((that.playerPosX)/50)==that.nextCell.posY&&parseInt((that.playerPosY)/50)==that.nextCell.posX)) {
        that.getNewDirection();
      }
    }, 300);
  }
}

fighter = new Ai(3, 50, 50);
fighter.createPlayer();
//fighter.setMode();
//ighter.getRoads();
fighter.movement = ['up', 'right', 'down', 'left', 'bomb'];
fighter.sprite = ['avatar_up', 'avatar_right', 'avatar_down', 'avatar_left'];
fighter.getMovePlayer();

