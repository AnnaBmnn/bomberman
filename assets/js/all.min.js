class Bomb {
    constructor(powerKill, posX, posY, delay, owner, div) {
        this.powerDestruct = 1; // number of cells that can be destructed, always one
        this.powerKill = powerKill; // power range to kill players around
        this.delay = delay;
        this.posX = posX;
        this.posY = posY;
        this.owner = owner;
        this.div = div;
    }
    launchBomb() {
        this.div = document.createElement('div');
        this.div.classList.add('bomb');
        this.div.style.top = this.posY + 13 + "px"; // + 13 to place the bomb at his feet
        this.div.style.left = this.posX + 13 + "px";
        var map = document.querySelector('.map');        
        map.appendChild(this.div); 
    }
    destructingBomb() {
        var coordCellX = parseInt(this.posY / 50),
            coordCellY = parseInt(this.posX / 50);
        // test if the player is around the bomb + if there is some walls to break, according to the powerKill of the bomb
        if (map.cells[coordCellX - 1][coordCellY].status !== 'unbreakable' || map.cells[coordCellX + 1][coordCellY].status !== 'unbreakable') { // prevent breakable cells to be destruct if they are behind unbreakable cell
            for (var i = coordCellX - this.powerDestruct; i <= coordCellX + this.powerDestruct; i++) {
            if (0 < i && i < map.rows) {
                if (map.cells[i][coordCellY].status == 'breakable') {
                    if (map.cells[i][coordCellY].secondary_status == 'bonus')
                    {
                        map.cells[i][coordCellY].updateStatus('bonus_', true);   
                    } else 
                        map.cells[i][coordCellY].updateStatus('empty', true);
                }
            }
        }
        }
        if (map.cells[coordCellY - 1][coordCellX].status !== 'unbreakable' || map.cells[coordCellY + 1][coordCellX].status !== 'unbreakable') {
            for (var i = coordCellY - this.powerDestruct; i <= coordCellY + this.powerDestruct; i++) { // test on X
                if (0 < i && i < map.columns) {
                    if (map.cells[i][coordCellY].status == 'breakable') {
                        if (map.cells[i][coordCellY].secondary_status == 'bonus')
                        {
                            map.cells[i][coordCellY].updateStatus('bonus_', true);   
                        } else 
                            map.cells[i][coordCellY].updateStatus('empty', true);
                }
                }
            }
        }
        this.div.classList.remove('bomb');  
    }
    killingBomb() {
        var coordCellX = parseInt(this.posY / 50),
            coordCellY = parseInt(this.posX / 50);

        // testing if some players are around
        for (var i = coordCellX - this.powerKill; i <= coordCellX + this.powerKill; i++) { // test on Y
            if (0 < i && i < map.rows) {
                for (var j = 0; j < map.pirates.length; j++) {
                    if (map.cells[i][coordCellX].posY === parseInt(map.pirates[j].playerPosY/50) && map.cells[i][coordCellY].posX === parseInt(map.pirates[j].playerPosX/50)) {
                        map.pirates[j].playerLives -= 1;
                        return true;
                        //don't test for x
                    }
                }
            }
        }

        for (var i = coordCellY - this.powerKill; i <= coordCellY + this.powerKill; i++) { // test on X
            if (0 < i && i < map.columns) {
                for (var j = 0; j < map.pirates.length; j++) {
                    if (map.cells[coordCellY][i].posX === parseInt(map.pirates[j].playerPosX/50) && map.cells[coordCellX][i].posY === parseInt(map.pirates[j].playerPosY/50)) {
                        map.pirates[j].playerLives -= 1;
                    }
                }
            }
        }

    }
}

//object cell
var cell = function(posX, posY, status, secondary_status, div) {
    this.posX = posX;
    this.posY = posY;
    this.status = status;
    this.secondary_status = secondary_status;
    this.div = div;

    this.createDiv = function(map) {
        this.div = document.createElement('div');
        this.div.classList.add('cell');
        this.div.classList.add(this.status);
        if (!this.secondary_status == null)
            this.div.classList.add(this.secondary_status);
        
        map.appendChild(this.div);
    }

    // newStatus --> Status we want to had / removeStatus --> true or false (removing previous status)
    this.updateStatus = function(newStatus, removeStatus) {
        if (removeStatus)
            this.div.classList.remove(this.status);
        
        this.status = newStatus;
            
        this.div.classList.add(newStatus);
    }
}

/*
CELL.STATUS

cell.status = empty --> cell is empty
cell.status = unbreakable --> cell is an unbreakable wall
cell.status = breakable --> cell is an breakable wall

*/
var spawnCorner = 4;

var map = function(rows, columns) {
    this.rows = rows;
    this.columns = columns;
    this.div = document.querySelector('.map');
    this.cells = [rows];
    this.pirates = []; // contains all the players, used by the bomb to know if the bomb kills players or not according to their position on the map
    this.breakableWalls = 100;
    this.bonusNumber = 80;

    this.generateMap = function() {
        for (var i = 0; i < this.rows; i++) {
            this.cells[i] = [this.columns];

            for (var j = 0; j < this.columns; j++) {
                //define the cell with status unbreakable depending on their place
                var status = 'empty';
                if (this.isUnbreakable(i, j))
                    status = 'unbreakable'
                //define the cell with status breakable randomly
                var myCell = new cell(i, j, status, null);
                myCell.createDiv(this.div);
                this.cells[i][j] = myCell;
            }
        }
    }
    this.generateBreakableWall = function() {
        for (var k = 0; k < this.breakableWalls; k++) {
            //random x and y while the cell[x][y] is a corner or a unbreakableWall
            do {
                var x = alea(1, this.rows);
                var y = alea(1, this.columns);
                if (this.bonusNumber > 0) {
                    var bonus = Math.round(Math.random());
                    if (bonus === 1)
                        this.bonusNumber--;
                }
            } while ( (this.isUnbreakable(x, y)) || (this.isCorner(x, y)));
            
            this.cells[x][y].updateStatus('breakable', true);
            
            if (bonus === 1) {
                this.cells[x][y].secondary_status = 'bonus';
            }
        }
    }

    //test the cell[x][y] is unbreakable depending on their place
    this.isUnbreakable = function(x, y) {
        if (x == 0 || x == this.rows - 1 || y == 0 || y == this.columns - 1) // all the cells around
            return true;
        else
        if (y % 2 == 0 && x % 2 == 0) // one cell / 2
            return true;
        return false;
    }

    //test if the cells[x][y] is a corner case (corner case + or - number of powercase) or not
    this.isCorner = function(x, y) {
        //check if the random number give a cell in the corner
        if (x == 1) {
            if (y >= 1 && y <= spawnCorner)
                return true;
            else
            if (y <= this.columns && y >= this.columns - spawnCorner - 1)
                return true;
        }
        if (x == this.rows - 2) {
            if (y >= 1 && y <= spawnCorner)
                return true;
            else
            if (y <= this.columns && y >= this.columns - spawnCorner - 1)
                return true;
        }
        if (y == 1) {
            if (x >= 1 && x <= spawnCorner)
                return true;
            else
            if (x <= this.rows && x >= this.rows - spawnCorner - 1)
                return true;
        }
        if (y == this.columns - 2) {
            if (x >= 1 && x <= spawnCorner)
                return true;
            else
            if (x <= this.rows && y >= this.rows - spawnCorner - 1)
                return true;
        }
        return false;
    }
}

function alea(min, max) {
    return (Math.floor((max - min) * Math.random()) + min);
}

var map = new map(13, 17);
console.log(map.cells);
map.generateMap();
map.generateBreakableWall();

// Generate our player
var pirate_player = function(playerLives, playerPosX, playerPosY, div) {    
    this.playerLives = playerLives;    
    this.playerPosX = playerPosX;    
    this.playerPosY = playerPosY; 
    this.movement = new Array(); 
    this.bombDelay = 2000;  
    this.bombKill = 2;
    this.enableBomb = 1; //number of bomb you can launch  
    this.div = div;    
    this.createPlayer = function() {  
            map.pirates[map.pirates.length] = this; // add the player into the players array   
            this.div = document.createElement('div');        
            this.div.classList.add('avatar_down');
            this.div.style.top = this.playerPosY + 'px';
            this.div.style.left = this.playerPosX + 'px';        
            var mapDiv = document.querySelector('.map');        
            mapDiv.appendChild(this.div);    
        },
        this.movePlayer = function() {
            var that = this;
            that.playerPosX = playerPosX;
            that.playerPosY = playerPosY;
            window.addEventListener('keydown', function(e) {
                // Position calcul
                that.posX = Math.floor(that.playerPosX / 50); //
                that.posY = Math.floor(that.playerPosY / 50); //
//                console.log("Pos x " + that.posX);
//                console.log("Pos y " + that.posY);
//                console.log("PosX Player " + that.playerPosX);
//                console.log("PosY Player " + that.playerPosY);


                if (e.keyCode == that.movement[0]) {
                    //up
                    that.posX = Math.floor((that.playerPosX + 15) / 50); //
                    that.posY = Math.floor((that.playerPosY + 25) / 50); //
                    if ( (map.cells[that.posY][that.posX].status === 'empty') || (map.cells[that.posY][that.posX].status === 'bonus_') ) {
                        that.playerPosY -= 5;
                        that.div.classList.remove(that.sprite[1], that.sprite[2], that.sprite[3]);
                        that.div.classList.add(that.sprite[0]);
                        
                        if (map.cells[that.posY][that.posX].status === 'bonus_')
                            map.cells[that.posY][that.posX].updateStatus('empty', true);
                    }
                } else if (e.keyCode == that.movement[1]) {
                    //right
                    that.posX = Math.floor((that.playerPosX + 35) / 50); //
                    that.posY = Math.floor((that.playerPosY + 30) / 50); //
                    if ( (map.cells[that.posY][that.posX].status === 'empty') || (map.cells[that.posY][that.posX].status === 'bonus_') ) {
                        that.playerPosX += 5;
                        that.div.classList.remove(that.sprite[0], that.sprite[2], that.sprite[3]);
                        that.div.classList.add(that.sprite[1]);
                        
                        if (map.cells[that.posY][that.posX].status === 'bonus_')
                            map.cells[that.posY][that.posX].updateStatus('empty', true);
                    }
                } else if (e.keyCode == that.movement[2]) {
                    //down
                    that.posX = Math.floor((that.playerPosX + 15) / 50); //
                    that.posY = Math.floor((that.playerPosY + 35) / 50); //
                    if ( (map.cells[that.posY][that.posX].status === 'empty') || (map.cells[that.posY][that.posX].status === 'bonus_') ) {
                        that.playerPosY += 5;
                        that.div.classList.remove(that.sprite[1], that.sprite[0], that.sprite[3]);
                        that.div.classList.add(that.sprite[2]);
                        
                        if (map.cells[that.posY][that.posX].status === 'bonus_')
                            map.cells[that.posY][that.posX].updateStatus('empty', true);
                    }
                } else if (e.keyCode == that.movement[3]) {
                    //left
                    that.posX = Math.floor((that.playerPosX - 5) / 50); //
                    that.posY = Math.floor((that.playerPosY + 30) / 50); //
                    if ( (map.cells[that.posY][that.posX].status === 'empty') || (map.cells[that.posY][that.posX].status === 'bonus_') ) {
                        that.playerPosX -= 5;
                        that.div.classList.remove(that.sprite[1], that.sprite[2], that.sprite[0]);
                        that.div.classList.add(that.sprite[3]);
                        
                        if (map.cells[that.posY][that.posX].status === 'bonus_')
                            map.cells[that.posY][that.posX].updateStatus('empty', true);
                    }
                } else if (e.keyCode == that.movement[4] && that.enableBomb > 0) {
                    //space bar to launch a bomb
                    map.pirates[map.pirates.length-1].playerPosY = that.playerPosY; // update the position of the player at each bomb launch
                    map.pirates[map.pirates.length-1].playerPosX = that.playerPosX;
                    that.createBomb();
                }
                that.div.style.top = that.playerPosY + "px";
                that.div.style.left = that.playerPosX + "px";
            }, false);
        },
        this.createBomb = function() {
            this.enableBomb -= 1;
            let bomb = new Bomb(this.bombKill, this.playerPosX, this.playerPosY, this.bombDelay, this);
            bomb.launchBomb();
            setTimeout(function(){ // delay until the player can launch a bomb again
              pirate_player.enableBomb += 1;
              bomb.destructingBomb();
              bomb.killingBomb();
            }, this.bombDelay);
        };
}

var pirate_player = new pirate_player(3, 50, 50);
pirate_player.createPlayer();
pirate_player.movement = [38, 39, 40, 37, 32];
pirate_player.sprite = ['avatar_up', 'avatar_right', 'avatar_down', 'avatar_left'];
pirate_player.movePlayer();
